// Importar las librerías necesarias
import * as THREE from 'three';
import { Holistic } from '@mediapipe/holistic';
import { Camera } from '@mediapipe/camera_utils';

// Definir las constantes
const MODEL_URL = 'https://nicolascumbej.github.io/arexperience/tmp2h0xvw1a.obj';
const VIDEO_WIDTH = 1280;
const VIDEO_HEIGHT = 720;

// Definir la clase HatAR
class HatAR {
  constructor() {
    this.videoElement = document.getElementById('input_video');
    this.canvasElement = document.getElementById('canvas');
    this.canvasCtx = this.canvasElement.getContext('2d');
    this.labelElement = document.getElementById('label');
    this.modelInfoElement = document.getElementById('modelInfo');
    this.hat = document.querySelector('#hat');

    this.holistic = new Holistic({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}` });
    this.holistic.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: true,
      refineFaceLandmarks: true,
      minDetectionConfidence: 0.8,
      minTrackingConfidence: 0.8
    });

    this.holistic.onResults(this.onResults.bind(this));
    this.startCamera();
  }

  async startCamera() {
    try {
      const camera = new Camera(this.videoElement, {
        onFrame: async () => {
          await this.holistic.send({ image: this.videoElement });
        },
        width: VIDEO_WIDTH,
        height: VIDEO_HEIGHT
      });
      await camera.start();
    } catch (error) {
      console.error('Error al acceder a la cámara:', error);
      alert('No se pudo acceder a la cámara. Verifica los permisos y asegúrate de que no esté siendo utilizada por otra aplicación.');
    }
  }

  onResults(results) {
    if (!this.hat || !this.hat.object3D) {
      return;
    }

    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
      const landmarks = results.faceLandmarks;

      this.drawLandmarks(landmarks);
      this.updateHatPosition(landmarks);
      this.updateHatRotation(landmarks);
      this.updateHatScale(landmarks);

      this.hat.setAttribute('visible', true);
      this.updateLabel(landmarks);
      this.updateModelInfo(this.hat.object3D.position);
    } else {
      this.hat.setAttribute('visible', false);
      this.labelElement.style.display = 'none';
      this.modelInfoElement.style.display = 'none';
    }
  }

  drawLandmarks(landmarks) {
    // Dibujar los puntos de referencia faciales en el canvas
  }

  updateHatPosition(landmarks) {
    // Calcular la posición del modelo en función de los puntos de referencia faciales
  }

  updateHatRotation(landmarks) {
    // Calcular la rotación del modelo en función de los puntos de referencia faciales
  }

  updateHatScale(landmarks) {
    // Calcular la escala del modelo en función de los puntos de referencia faciales
  }

  updateLabel(landmarks) {
    // Actualizar la información de la cara en la interfaz de usuario
  }

  updateModelInfo(position) {
    // Actualizar la información del modelo en la interfaz de usuario
  }
}

// Crear una instancia de la clase HatAR
const hatAR = new HatAR();
